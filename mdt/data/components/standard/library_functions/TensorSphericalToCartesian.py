from mdt.component_templates.library_functions import LibraryFunctionTemplate
from mot.cl_data_type import SimpleCLDataType
from mot.model_building.parameters import LibraryParameter

__author__ = 'Robbert Harms'
__date__ = "2015-06-21"
__maintainer__ = "Robbert Harms"
__email__ = "robbert.harms@maastrichtuniversity.nl"


class TensorSphericalToCartesian(LibraryFunctionTemplate):

    description = '''
        Generates the D matrix for a Tensor compartment.

        The angles ``theta`` and ``phi`` are used for creating the first vector, ``vec0``. 
        Next, ``vec0`` is rotated 90 degrees in the (x, z) plane to form a vector perpendicular to the 
        principal direction. This vector is then rotated around ``psi`` to generate the first perpendicular 
        orientation, ``vec1``. The third vector is generated by being perpendicular to the other two vectors.

        Args:
            theta: polar angle of the first vector
            phi: azimuth angle of the first vector
            psi: rotation around the first vector, used to generate the perpendicular vectors.
    '''
    dependency_list = ['RotateVectors']
    parameter_list = ['theta', 'phi', 'psi',
                      LibraryParameter('mot_float_type4*', 'vec0'),
                      LibraryParameter('mot_float_type4*', 'vec1'),
                      LibraryParameter('mot_float_type4*', 'vec2')]
    cl_code = '''
        mot_float_type cos_theta;
        mot_float_type sin_theta = sincos(theta, &cos_theta);
        mot_float_type cos_phi;
        mot_float_type sin_phi = sincos(phi, &cos_phi);
        
        *vec0 = (mot_float_type4)(cos_phi * sin_theta, sin_phi * sin_theta, cos_theta, 0.0);

        // rotate vec0 by 90 degrees, changing, x, y and z
        mot_float_type rotation_factor = sin(theta+(M_PI_2_F));
        *vec1 = (mot_float_type4)(rotation_factor * cos_phi,
                                  rotation_factor * sin_phi,
                                  cos(theta+(M_PI_2_F)),
                                  0.0);
        
        *vec1 = RotateVectors(*vec0, *vec1, psi);
        *vec2 = cross(*vec0, *vec1);
    '''
